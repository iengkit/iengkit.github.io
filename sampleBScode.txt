# SAMPLE CODE FROM THE ACTUAL PROGRAM 

def simulate(S_0, volatility, T):
    price = np.zeros(T+1)
    price[0] = S_0
    for t in range(T):
        price[t+1] = price[t] * np.exp(-volatility**2/2.0 + np.random.randn()*volatility)
    return price

def smooth(data, W):
    T = len(data)
    smoothed_data = np.zeros(T)
    for t in range(T):
        count = 0
        for window in range(t-W, t+W+1):
            if window >= 0 and window < T:
                smoothed_data[t] += price[window]
                count += 1
        smoothed_data[t] /= count
    return smoothed_data        

def blackScholes(S_0, strike_price, volatility, T):
    d1 = (np.log(S_0/strike_price) + (volatility**2/2.0)*T) / (volatility*np.sqrt(T))
    d2 = (np.log(S_0/strike_price) + (-volatility**2/2.0)*T) / (volatility*np.sqrt(T))
    return scipy.stats.norm.cdf(d1)*S_0 - scipy.stats.norm.cdf(d2)*strike_price

initial_price = 10
volatility = 0.01
T = 1000
strike_price = 80
W = 25
N_repeats = 1000
price = simulate(initial_price, volatility, T)
from pylab import *
plt.plot(price)
smoothed_price = smooth(price, W)
plt.plot(smoothed_price, 'r')
##plt.show()

simulated_option_prices = np.zeros(N_repeats)

simulated_option_prices = np.zeros(N_repeats)
for i in range(N_repeats):
    end_price = simulate(initial_price, volatility, T)[-1]
    if end_price < strike_price:
        simulated_option_prices[i] = 0.0
    else:
        simulated_option_prices[i] = end_price-strike_price
np.mean(simulated_option_prices)
blackScholes(initial_price, strike_price, volatility, T)




























